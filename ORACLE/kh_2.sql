--직급이 대표, 부사장이 아닌 모든 사원을 이름, 부서명, 직급코드 출력
--조건 대표 OR 부사장 NOT IN
SELECT EMP_NAME, DEPT_TITLE, JOB_CODE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
JOIN JOB USING(JOB_CODE)
WHERE JOB_NAME NOT IN ('대표','부사장');
--WHERE SELECT JOB_CODE FROM JOB WHERE JOB_NAME IN ('대표','부사장');

--다중열 서브쿼리
--퇴사한 여직원이 한명 그 지원이랑 같은부서, 같은직급에 해당하는 사원의 이름, 직급, 부서코드 조회


-- 단일행
SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y';
SELECT DEPT_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y';
SELECT JOB_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y';
--1)
SELECT EMP_NAME, JOB_CODE, DEPT_CODE FROM EMPLOYEE
WHERE
DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y')
AND
JOB_CODE = (SELECT JOB_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y');
--2)
SELECT EMP_NAME , JOB_CODE, DEPT_CODE FROM EMPLOYEE
WHERE
(DEPT_CODE,JOB_CODE) IN (SELECT DEPT_CODE, JOB_CODE FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1)=2 AND ENT_YN='Y');

--기술지원부이면서, 급여가 200만원인 직원의 이름, 부서코드, 급여, 부서 지역명(LOCATION)
SELECT EMP_NAME, DEPT_CODE, SALARY,LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT  ON (DEPT_CODE=DEPT_ID)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE)
WHERE DEPT_TITLE = '기술지원부' AND SALARY =2000000;


SELECT EMP_NAME, DEPT_CODE, SALARY,LOCAL_NAME
FROM EMPLOYEE
JOIN LOCATION ON (DEPT_CODE, LOCAL_CODE) IN (SELECT DEPT_ID,LOCATION_ID FROM DEPARTMENT WHERE DEPT_TITLE ='기술지원부')
WHERE SALARY = 2000000;


--다중행 다중열 서브쿼리 : 서브쿼리 조회결과가 컬럼개수와 행의개수가 여러개일때
--직급별로 최소급여를 받는 직원의 이름, 직급, 월급
--WHERE 컬럼수랑 서브쿼리 컬럼수랑 순서와 수가 같아야 함.
SELECT EMP_NAME,JOB_CODE, SALARY 
FROM EMPLOYEE
WHERE (JOB_CODE,SALARY) IN (SELECT JOB_CODE,MIN(SALARY) FROM EMPLOYEE GROUP BY JOB_CODE);

------------------------------------------------------------------------------------------
--  상관쿼리(상호연관서브쿼리)
--  메인쿼리의 값을 서브쿼리에 주고 서브쿼리를 수행하고, 그 결과를 다시 메인쿼리로 반환해서 수행하는 쿼리
--  성능이 좋지 않음
--  서브쿼리의 WHERE을 수행하기 위해 메인쿼리가 먼저 수행되는 구조
--  메인쿼리의 각 행의 값마다 응답이 달라져야 하는 경우 사용

--  부서가 '인사관리부','회계관리부','마케팅부'인 직원의 이름, 부서코드, 급여
SELECT EMP_NAME, DEPT_CODE, SALARY 
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE)
WHERE DEPT_TITLE IN('인사관리부','회계관리부','마케팅부');

SELECT EMP_NAME, DEPT_CODE, SALARY 
FROM EMPLOYEE
WHERE DEPT_CODE IN (SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE IN('인사관리부','회계관리부','마케팅부'));


SELECT EMP_NAME, DEPT_CODE, SALARY 
FROM EMPLOYEE E
WHERE EXISTS (
    SELECT DEPT_ID FROM DEPARTMENT 
    D WHERE DEPT_TITLE IN('인사관리부','회계관리부','마케팅부')
    AND E.DEPT_CODE =D.DEPT_ID
);

--스칼라 서브쿼리 : 상관쿼리이면서 결과값이 1개인 서브쿼리
--1) WHERE절에 사용
--자신이 속한 직급의 평균 급여보다 급여를 많이받는 직원의 이름, 직급코드, 급여주회
SELECT EMP_NAME, JOB_CODE, SALARY 
FROM EMPLOYEE E1
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE E2.JOB_CODE = E1.JOB_CODE); --본인이 속한 직급의 평균급어

--2) SELECT절에 사용
-- 사원명, 부서코드, 부서별 평균임금을 출력
SELECT EMP_NAME, DEPT_CODE,FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE E2 WHERE NVL(E1.DEPT_CODE,'없음')= NVL(E2.DEPT_CODE,'없음')GROUP BY DEPT_CODE))
AS "부서별 평균 임금"
FROM EMPLOYEE E1;
-- 사원명, 관리자 사번, 관리자 이름
SELECT EMP_NAME, MANAGER_ID,
NVL((SELECT E2.EMP_NAME FROM EMPLOYEE E2 WHERE E1.MANAGER_ID = E2.EMP_ID),'없음') AS 관리자이름
FROM EMPLOYEE E1;

--3) 스칼라서브쿼리 ORDER BY절에 사용
-- 이름, 부서코드, 급여 출력하는데 정렬은 부서이름기준
SELECT EMP_NAME,DEPT_CODE, SALARY 
FROM EMPLOYEE 
ORDER BY (SELECT DEPT_TITLE FROM DEPARTMENT WHERE DEPT_CODE=DEPT_ID);

-------------------------------------------------------------------------------
--인라인 뷰 : FROM절에서 사용되는 서브쿼리
SELECT EMP_NAME , DEPT_CODE, JOB_CODE, SALARY,EMP_NO,EMP_ID FROM EMPLOYEE;

SELECT EMP_NAME, SALARY FROM (SELECT EMP_NAME , DEPT_CODE, JOB_CODE, SALARY FROM EMPLOYEE);

--TOP-N분석
--현재 직원중에 급여를 가장 많이받는 5명 
--ROWNUM : 출력되는 행마다 자동으로 순차적인 번호를 붙여주는 값
SELECT ROWNUM,EMP_NAME,SALARY FROM EMPLOYEE ORDER BY SALARY DESC;

SELECT EMP_NAME,SALARY FROM (SELECT EMP_NAME,SALARY FROM EMPLOYEE ORDER BY SALARY DESC) WHERE ROWNUM < 6;

--RANK() OVER : 중복 순위 다음은 해당 갯수만큼 건너뛰고 반환
SELECT EMP_NAME, SALARY, RANK() OVER (ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE;
--DENSE_RANK() OVER : 중복순위와 상관없이 순차적으로 반환
SELECT EMP_NAME, SALARY, DENSE_RANK() OVER (ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE;
--ROW_NUMBER() OVER : 중복과 관계없이 무조건 순서대로 반환 
SELECT EMP_NAME, SALARY, ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS 순위 FROM EMPLOYEE;



--SUBQUERY를 이용한 테이블 생성
/*
테이블생성 구문
CREATE TABLE 테이블이름(컬럼명 데이터타입 제약조건, ...);
*/
CREATE TABLE EMP_COPY
AS
SELECT EMP_ID,EMP_NAME,NVL(DEPT_TITLE,'부서없음') DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE)
LEFT JOIN JOB USING(JOB_CODE)
ORDER BY 1;

SELECT * FROM EMP_COPY;
SELECT * FROM EMPLOYEE;

--컬럼명만 생성(값은 제외) 
CREATE TABLE EMP_COPY1
AS
SELECT * FROM EMPLOYEE WHERE 1=0;

SELECT * FROM EMP_COPY1;

DROP TABLE EMP_COPY;
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEE;

SELECT * FROM EMP_COPY;
--SUBQUERY를 이용한 수정
--UPDATE 테이블명 SET 수정컬럼 = 수정값 WHERE 조건
--방명수 직원의 급여를 선동일의 급여로 변경
--1)선동일의 급여검색
SELECT SALARY FROM EMP_COPY WHERE EMP_NAME='선동일';
--2)방명수 급여 변경
UPDATE EMP_COPY SET SALARY = (SELECT SALARY FROM EMP_COPY WHERE EMP_NAME='선동일') WHERE EMP_NAME='방명수';
SELECT * FROM EMP_COPY;

--SUBQUREY를 이용한 삭제
--방명수직원과 같은 부서의 직원 모두 삭제
--1) 방명수 부서코드 검색
SELECT DEPT_CODE FROM EMP_COPY WHERE EMP_NAME = '방명수';
--2) 방명수와 같은부서 직원 삭제
DELETE FROM EMP_COPY WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMP_COPY WHERE EMP_NAME = '방명수');

SELECT * FROM EMP_COPY ORDER BY EMP_NAME;

--SUBQUERY를 이용한 INSERT
CREATE TABLE EMP1 
AS
SELECT EMP_ID,EMP_NAME,DEPT_CODE FROM EMPLOYEE WHERE 1=0;

CREATE TABLE EMP2
AS
SELECT EMP_ID,EMP_NAME,DEPT_CODE FROM EMPLOYEE WHERE 1=0;
SELECT * FROM EMPLOYEE;

CREATE TABLE EMP3
AS
SELECT EMP_ID,EMP_NAME,JOB_CODE FROM EMPLOYEE WHERE 1=0;

INSERT INTO EMP1 VALUES (1,'강은현','D5');

INSERT INTO EMP1 (SELECT EMP_ID,EMP_NAME,DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME='송종기');

INSERT INTO EMP2 (SELECT EMP_ID,EMP_NAME,DEPT_CODE FROM EMPLOYEE);

DELETE FROM EMP2;

SELECT * FROM EMP1;
SELECT * FROM EMP2;
SELECT * FROM EMP3;

INSERT ALL 
INTO EMP2 VALUES(EMP_ID,EMP_NAME,DEPT_CODE)
INTO EMP3 VALUES(EMP_ID,EMP_NAME,JOB_CODE)
SELECT EMP_ID,EMP_NAME,DEPT_CODE,JOB_CODE FROM EMPLOYEE;

COMMIT;

CREATE TABLE USERTBL(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR(20) UNIQUE,
    USER_PW VARCHAR(20) NOT NULL
);

INSERT INTO USERTBL VALUES(1,'USER01','1111');
INSERT INTO USERTBL VALUES(2,'USER02','2222');
INSERT INTO USERTBL VALUES(3,'USER03','3333');
INSERT INTO USERTBL VALUES(4,'USER04','4444');
SAVEPOINT sp1;
INSERT INTO USERTBL VALUES(5,'USER05','9999');
SELECT * FROM USERTBL;
COMMIT;
ROLLBACK;
ROLLBACK TO sp1;

DELETE FROM USERTBL;

UPDATE USERTBL SET USER_PW = '4544' WHERE USER_NO=2;

SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME='EMPLOYEE';
SELECT * FROM USER_COL_COMMENTS;

CREATE TABLE EMP01 
AS
SELECT EMP_NO, EMP_NAME , EMAIL,PHONE FROM EMPLOYEE;

SELECT * FROM EMP01;
SELECT * FROM EMPLOYEE;

UPDATE EMP01 SET PHONE = '01099999999' WHERE EMP_NAME ='심봉선';

CREATE VIEW EMP_VIEW 
AS
SELECT EMP_NO,EMP_NAME,EMAIL,PHONE FROM EMPLOYEE;
SELECT * FROM EMP_VIEW;


UPDATE EMP_VIEW SET PHONE ='01088888888' WHERE EMP_NAME='심봉선';
UPDATE EMPLOYEE SET PHONE ='01012341234' WHERE EMP_NAME ='심봉선';

CREATE OR REPLACE VIEW EMP_VIEW
AS
SELECT EMP_NO,EMP_NAME,DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON(DEPT_CODE=DEPT_ID);

SELECT * FROM EMP_VIEW;
SELECT * FROM EMPLOYEE;

UPDATE EMP_VIEW2 SET EMP_NO = '621235-1985699' WHERE EMP_NAME ='선동일';
--조인된 값은 직접적으로 EMPLOYEE 에 연결되어있지 않기 때문에
--생성수정삭제 할 수 없음.
/*
UPDATE EMP_VIEW 
SET DEPT_TITLE='해외영업2부' 
WHERE EMP_NAME='선동일';
*/


CREATE SEQUENCE TEST_SEQ
START WITH 10
INCREMENT BY 2
MAXVALUE 30
NOCYCLE
NOCACHE;

SELECT * FROM USER_SEQUENCES;

SELECT TEST_SEQ.CURRVAL FROM DUAL;
SELECT TEST_SEQ.NEXTVAL FROM DUAL;

CREATE SEQUENCE TEST_SEQ1
START WITH 10
INCREMENT BY 2
MAXVALUE 30
CYCLE
NOCACHE; 
SELECT * FROM USER_SEQUENCES;
SELECT TEST_SEQ1.CURRVAL FROM DUAL;
SELECT TEST_SEQ1.NEXTVAL FROM DUAL;

CREATE TABLE SEQ_TEST1(
    NO NUMBER PRIMARY KEY,
    NAME VARCHAR(20) NOT NULL,
    AGE NUMBER NOT NULL
);
CREATE SEQUENCE SEQ_TEST1_NO
START WITH 10
INCREMENT BY 10
MAXVALUE 100
NOCYCLE
NOCACHE;
-- L-1, L-2, L-3

INSERT INTO SEQ_TEST1 VALUES(SEQ_TEST1_NO.NEXTVAL,'강은현',30);
INSERT INTO SEQ_TEST1 VALUES(SEQ_TEST1_NO.NEXTVAL,'강은현2',23);
INSERT INTO SEQ_TEST1 VALUES(SEQ_TEST1_NO.NEXTVAL,'강은현3',43);
INSERT INTO SEQ_TEST1 VALUES(SEQ_TEST1_NO.NEXTVAL,'강은현4',52);
DELETE FROM SEQ_TEST1 WHERE NO=20;
SELECT * FROM SEQ_TEST2;

CREATE TABLE SEQ_TEST2(
    NO VARCHAR2(5) PRIMARY KEY,
    NAME VARCHAR(20) NOT NULL,
    AGE NUMBER NOT NULL
);

CREATE SEQUENCE SEQ_TEST2_NO;
INSERT INTO SEQ_TEST2 VALUES('L-'||SEQ_TEST2_NO.NEXTVAL,'강은현',20);
INSERT INTO SEQ_TEST2 VALUES('L-'||SEQ_TEST2_NO.NEXTVAL,'강은현1',30);

--시퀀스 생성
--시작값 100, 최댓값 500, 증가폭 50, 반복없고, 캐시X -> TEST_SEQ2

ALTER SEQUENCE TEST_SEQ2
INCREMENT BY 50
MAXVALUE 500
NOCYCLE
NOCACHE;

DROP SEQUENCE TEST_SEQ2;

/*
KH_MEMBER 테이블
MEMBER_NO 숫자
MEMBER_NAME 문자
MEMBER_AGE 숫자
MEMBER_JOIN_COM 숫자

MEMBER_NO,MEMBER_JOIN_COM 시퀀스로 처리
MEMBER_NO : 500번부터 시작해서 10씩증가
JOIN_COM : 1부터 시작해서 1씩증가
두 시퀀스 모두 최대값은 10000/반복X/CACHE X
*/
CREATE TABLE KH_MEMBER(
    MEMBER_NO NUMBER,
    MEMBER_NAME VARCHAR2(20),
    MEMBER_AGE VARCHAR2(20),
    MEMBER_JOIN_COM NUMBER
);
CREATE SEQUENCE SEQ_MEMBER_NO
START WITH 500
INCREMENT BY 10
MAXVALUE 1000
NOCYCLE
NOCACHE;

CREATE SEQUENCE SEQ_MEMBER_JOIN_NO
START WITH 1
INCREMENT BY 1
MAXVALUE 1000
NOCYCLE
NOCACHE;

SELECT * FROM KH_MEMBER;
INSERT INTO KH_MEMBER VALUES(SEQ_MEMBER_NO.NEXTVAL,'강은현1',20,SEQ_MEMBER_JOIN_NO.NEXTVAL);
INSERT INTO KH_MEMBER VALUES(SEQ_MEMBER_NO.NEXTVAL,'강은현2',30,SEQ_MEMBER_JOIN_NO.NEXTVAL);
INSERT INTO KH_MEMBER VALUES(SEQ_MEMBER_NO.NEXTVAL,'강은현3',40,SEQ_MEMBER_JOIN_NO.NEXTVAL);
INSERT INTO KH_MEMBER VALUES(SEQ_MEMBER_NO.NEXTVAL,'강은현4',50,SEQ_MEMBER_JOIN_NO.NEXTVAL);
INSERT INTO KH_MEMBER VALUES(SEQ_MEMBER_NO.NEXTVAL,'강은현5',60,SEQ_MEMBER_JOIN_NO.NEXTVAL);

