SELECT * FROM EMPLOYEE;

SELECT EMP_NAME,EMAIL,PHONE FROM EMPLOYEE;
SELECT * FROM EMPLOYEE WHERE JOB_CODE='J5';
--EMPLOYEE 테이블에서 사원명, 전화번호, 월급 조회
SELECT EMP_NAME, PHONE,SALARY FROM EMPLOYEE;
--EMPLOYEE 테이블에서 사원명, 전화번호, 월급 조회 월급이 300만원이상인 사람만 조회
SELECT EMP_NAME, PHONE,SALARY FROM EMPLOYEE WHERE SALARY>=3000000;
--EMPLOYEE 테이블에서 사원명, 전화번호, 월급 조회 월급이 300만원이상이면서 직급코드가 J3인 사람만 조회
SELECT EMP_NAME, PHONE,SALARY FROM EMPLOYEE WHERE SALARY>=3000000 AND JOB_CODE='J3';
--EMPLOYEE 테이블에서 사원명, 월급, 연봉조회
SELECT EMP_NAME AS "이름",SALARY AS "월급", SALARY*12 AS "연봉" FROM EMPLOYEE;
SELECT EMP_NAME "이름",SALARY "월급", SALARY*12 "연봉" FROM EMPLOYEE;
SELECT EMP_NAME NAME,SALARY "월급(원)", SALARY*12 연봉 FROM EMPLOYEE;
SELECT EMP_NAME,SALARY,'원' FROM EMPLOYEE;

--EMPLOYEE 테이블에서 이름,연봉,총수령액(보너스가 포함된 금액), 실수령액(총 수령액 - (월급*세금 3%))
--보너스와 세금은 매달 적용됨
SELECT EMP_NAME,SALARY*12 연봉, (SALARY+(SALARY*BONUS))*12 총수령액,(SALARY+(SALARY*BONUS))*12-(SALARY*0.03*12) 실수령액 FROM EMPLOYEE;

--날짜 +1 -> 다음날 날짜, 날짜-1 -> 어제날짜, 다음날 날짜 - 어제날짜
SELECT EMP_NAME 이름,FLOOR(SYSDATE-HIRE_DATE) 근무일수 FROM EMPLOYEE;

--실습 
--EMPLOYEE 테이블에서 20년 이상 근속한 직원의 이름, 월급, 보너스율을 출력
SELECT EMP_NAME, SALARY, BONUS FROM EMPLOYEE WHERE FLOOR(SYSDATE-HIRE_DATE)>=365*20;

SELECT * FROM EMPLOYEE;

--연결연산자
SELECT EMP_NAME,SALARY||'원' FROM EMPLOYEE; -- || SALARY와 '원'을 연결해주는 연산자

--논리 연산자 여러개 조건을 하나의 논리결과로 만들어주는 연산자
--부서 코드가 D6이고 급여를 200만원보다 많이받는 직원의 이름, 부서코드,급여 출력
SELECT EMP_NAME, DEPT_CODE, SALARY FROM EMPLOYEE WHERE DEPT_CODE='D6' AND SALARY>2000000;

--급여를 350만원보다 많이받고 600만원보다 적게받는 직원의 이름과 급여 조회
SELECT EMP_NAME, SALARY FROM EMPLOYEE WHERE SALARY>=3500000 AND SALARY <=6000000;

SELECT EMP_NAME,SALARY FROM EMPLOYEE
WHERE SALARY BETWEEN 3500000 AND 6000000;

--EMPLOYEE테이블에서 고용일 90/0101 ~ 01/01/01 인 사원의 전체 내용 출력
SELECT * FROM EMPLOYEE WHERE HIRE_DATE BETWEEN '90/01/01' AND '01/01/01';


--LIKE 연산자 '%', '_' ->와일드 카드
-- 와일드카드 : 아무거나 대체해서 사용할수 있는것

SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '전%'; -- %는 글자수 상관없이 전으로 시작하는 모든값 
SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '김%';
SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '전__';

--이름에 '유'가 포함되어 있는 직원의 모든 정보 출력
SELECT * FROM EMPLOYEE WHERE EMP_NAME LIKE '%유%';--앞 뒤에 % 넣어주면 유 포함되어있는 이름을 전부찾을수있음

--EMAIL 중 ID 중 _ 앞자리가 3자리인 직원 모든정보 출력
SELECT * FROM EMPLOYEE WHERE EMAIL LIKE'___%';  -- EMAIL 이 4글자이상인 
--ESCAPE옵션  "\"
SELECT * FROM EMPLOYEE WHERE EMAIL LIKE '___#_%' ESCAPE '#'; --#뒤에 문자는 와일드카드가아니라 문자야 표시
--NOT LIKE
SELECT EMP_NAME,SALARY FROM EMPLOYEE WHERE EMP_NAME NOT LIKE '전%'; --LIKE '전;하면 전씨만 2명 찾는데 NOTLIKE하면 전씨가 아닌사람찾는코드 그래서 21명이 출력됨 
SELECT * FROM EMPLOYEE;

--1. EMPLOYEE 테이블에서 이름끝이 연으로 끝나는 사원 이름
SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_NAME LIKE '%연';
--2. EMPLOYEE테이블에서 전화번호 처음 자리가 010이 아닌사원의 이름,전화번호 출력
SELECT EMP_NAME, PHONE FROM EMPLOYEE WHERE PHONE NOT LIKE '010%';
--3. EMPLOYEE테이블에서 메일주소에 'S'가 들어가면서,DEPT_CODE가 D9 또는 D6이며
--고용일이 90/01/01~00/12/01이면서, 월급이 270만원 이상인 사원의 전체정보 출력
SELECT * FROM EMPLOYEE 
WHERE EMAIL LIKE '%s%' AND (DEPT_CODE ='D9' OR DEPT_CODE='D6') AND
(HIRE_DATE BETWEEN '90/0101' AND '00/12/01') AND 
SALARY >=2700000;

--IS NUJLL/ IS NOT NULL
--관리자도 없고, 부서배치도 받지 않은 직원(부서코드(DEPT_CODE)가 NULL인 직원 이름조회
SELECT * FROM EMPLOYEE WHERE MANAGER_ID IS NULL AND DEPT_CODE IS NOT NULL;

--IN / NOT IN
--부서코드가 D6이거나 D9인 직원 전체정보조회
SELECT * FROM EMPLOYEE WHERE DEPT_CODE = 'D6' OR DEPT_CODE='D9' OR DEPT_CODE = 'D2';
SELECT * FROM EMPLOYEE WHERE DEPT_CODE NOT IN ('D6','D2','D9','D1');

--부서원 중 직급코드(JOB_CODE)가 J7 또는 J2이고, 급여가 200만원 초과인 사람의 이름,급여,직급코드 출력
SELECT EMP_NAME, SALARY , JOB_CODE FROM EMPLOYEE WHERE JOB_CODE IN ('J2','J7') AND SALARY>2000000;

--오름차순 ASC
--숫자 : 작은수 -> 큰수
--날짜 : 빠른날 -> 느린날
--문자 : 사전순

--내림차순 DESC
--숫자 : 큰수 -> 작은수
--날짜 : 늦은날 -> 빠른날
--문자 : 사전 역순

SELECT * FROM EMPLOYEE ORDER BY EMP_NAME DESC;

SELECT EMP_ID,EMP_NAME,EMAIL FROM EMPLOYEE ORDER BY SALARY;
--ORDER BY (몇번째컬럼인지)
SELECT EMP_ID,EMP_NAME,SALARY FROM EMPLOYEE ORDER BY 3 DESC;


--1
SELECT EMP_NAME 이름, EMP_NO 주민번호, SALARY 급여, HIRE_DATE 입사일 FROM EMPLOYEE
WHERE((SYSDATE-HIRE_DATE)>=365*5) AND ((SYSDATE-HIRE_DATE)<=365*10);
--2
SELECT EMP_NAME, DEPT_CODE,HIRE_DATE,FLOOR(ENT_DATE-HIRE_DATE)||'일' 근무기간, ENT_DATE FROM EMPLOYEE WHERE ENT_YN ='Y';
--3
SELECT EMP_NAME, SALARY+(SALARY*0.5) "인상 급여",(SYSDATE-HIRE_DATE)/365 근속년수 FROM EMPLOYEE
WHERE (SYSDATE-HIRE_DATE)>=365*10 ORDER BY 3;
--4
SELECT EMP_NAME, EMP_NO, EMAIL, PHONE, SALARY FROM EMPLOYEE
WHERE (HIRE_DATE BETWEEN '99/01/01' AND '10/01/01')AND SALARY <= 2000000;
--5
SELECT EMP_NAME, EMP_NO,SALARY, DEPT_CODE FROM EMPLOYEE WHERE
(SALARY BETWEEN 2000000 AND 3000000) AND EMP_NO LIKE '___4___2%'
ORDER BY 2 DESC;
--6
SELECT EMP_NAME, FLOOR((SYSDATE-HIRE_DATE)/1000)*(SALARY*0.1) "특별 보너스" FROM EMPLOYEE
WHERE EMP_NO LIKE '_______1%' AND BONUS IS NULL ORDER BY 1;

-----------------------------------------------------------------------

--1. 문자를 처리하는 함수
--  1) LENGTH : 주어진 값 또는 컬러의 문자열 길이(문자 개수)를 반환하는 함수
SELECT EMP_NAME,LENGTH(EMP_NAME) 이름길이,EMAIL,LENGTH(EMAIL) 이메일길이 FROM EMPLOYEE;
--  2) LEHGTH : 주어진 값 또는 컬럼의 문자열 길이(BYTE)를 변환하는 함수
SELECT EMP_NAME,LENGTHB(EMP_NAME),EMAIL,LENGTHB(EMAIL) FROM EMPLOYEE;
--  3) INSTR : 찾는 문자(열)이 지정한 위치부터 지정한 횟수만큼 나타난 위치를 반환
SELECT INSTR('HELLO WORLD HI HIGH','H',1,1) FROM DUAL;
SELECT INSTR('HELLO WORLD HI HIGH','H',1,2) FROM DUAL;
SELECT INSTR('HELLO WORLD HI HIGH','H',1,3) FROM DUAL;
SELECT INSTR('HELLO WORLD HI HIGH','H',2,1) FROM DUAL;
SELECT INSTR('HELLO WORLD HI HIGH','H',2,2) FROM DUAL;
SELECT INSTR('HELLO WORLD HI HIGH','H',-1,1) FROM DUAL;

--EMPLOYEE 테이블에서 EMAIL컬럼에서 @의 위치를 출력
SELECT EMAIL,INSTR(EMAIL,'@',1,1) FROM EMPLOYEE; 

--  4) LPAD/RPAD : 주어진 컬럼 문자열에 임의의 문자열을 왼쪽/오른쪽에 덧붙여 길이 N의 문자열을 반환
SELECT EMAIL, LENGTH(EMAIL),LPAD(EMAIL,20,'-') ,RPAD(EMAIL,20,'-')FROM EMPLOYEE;
SELECT EMAIL, LENGTH(EMAIL),LPAD(EMAIL,10,'-') ,RPAD(EMAIL,10,'-')FROM EMPLOYEE;
SELECT EMAIL,LPAD(EMAIL,INSTR(EMAIL,'@',1,1)-1,'#') FROM EMPLOYEE;

--  5) LTRIM/RTRIM : 주어진 컬럼이나 문자열의 왼쪽 또는 오른쪽에서 지정한 STR에 포함된 모든 문자를 제거한 나머지 변환
SELECT 'aaaKH' FROM DUAL;
SELECT LTRIM('aaaKH','a') FROM DUAL;
SELECT LTRIM('aaaKaH','a') FROM DUAL;
SELECT RTRIM('aaaKHaaa','a') FROM DUAL;

SELECT LTRIM('ABACAAABCKH','ABC')FROM DUAL;

--TRIM : 주어진 컬럼이나 문자열 앞/뒤/양쪽에 있는 지정한 문자를 제거한 나머지를 변환
SELECT TRIM(LEADING 'a' FROM 'aaaKHaaa')FROM DUAL;
SELECT TRIM(TRAILING 'a' FROM 'aaaKHaaa')FROM DUAL;
SELECT TRIM(BOTH 'a' FROM 'aaaKHaaa')FROM DUAL;
SELECT TRIM(BOTH 'B' FROM TRIM(LEADING 'A' FROM 'ABACAAABCKH'))FROM DUAL;

SELECT * FROM DEPARTMENT;
SELECT TRIM(TRAILING '부' FROM DEPT_TITLE) FROM DEPARTMENT;
--DUAL 테이블 사용
--'982341678934509hello89798739273402' 문자열의 앞 뒤 모든 숫자 제거
SELECT RTRIM(LTRIM('982341678934509hello89798739273402','0123456789'),'01234556789') FROM DUAL;

--  7) SUBSTR : 컬럼이나 문자열에서 지정한 위치부터 지정한 개수의 문자열을 잘라내어 리턴
SELECT 'SHOWMETHEMONEY' FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY',1,4) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY',5,2) FROM DUAL;
SELECT SUBSTR('SHOWMETHEMONEY',-8,2) FROM DUAL;
-- EMPLOYEE 테이블에서 사원명 중 성만 출력
SELECT SUBSTR(EMP_NAME,1,1) 성 FROM EMPLOYEE;
SELECT LPAD(EMP_NAME,2,'#') FROM EMPLOYEE;

--EMPLOYEE 테이블에서 남자만 사원번호, 사원명, 주민번호, 월급
--주민번호 뒤 6자리는 * 처리 EX) 990101-1******
SELECT * FROM EMPLOYEE;
SELECT EMP_ID, EMP_NAME, SUBSTR(EMP_NO,1,8)||'*******', SALARY FROM EMPLOYEE WHERE SUBSTR(EMP_NO,8,1) IN ('1','3');

--  8) LOWER / UPPER / INITCAP
SELECT LOWER('Welcome TO My World') FROM DUAL;
SELECT UPPER('Welcome TO My World') FROM DUAL;
SELECT INITCAP('Welcome TO My World') FROM DUAL;

--  9) CONCAT : 컬럼의 문자 혹은 문자열 두 개를 전달받아 하나로 합친 후 리턴
SELECT CONCAT('가나다라','ABCD'),'안녕하세요 'FROM DUAL;
SELECT '가나다라'||'ABCD'||'안녕하세요' FROM DUAL;

--  10) REPLACE : 문자열을 변환
SELECT REPLACE('next007@nate.com','nate.com','iei.or.kr')FROM DUAL;

-- 2. 숫자 처리함수
--  1) ABS : 절대값
SELECT ABS(10) FROM DUAL;
SELECT ABS(-10) FROM DUAL;
--  2) MOD : 인자로 받은 숫자를 나누어 나머지를 구하는 함수
SELECT MOD(10,3) FROM DUAL;
SELECT MOD(10,2) FROM DUAL;
SELECT MOD(10,4) FROM DUAL;
--  3) ROUND/FLOOR/CEIL : 반올림, 버림, 올림
SELECT FLOOR(126.465) FROM DUAL;
SELECT CEIL(126.465) FROM DUAL;
SELECT ROUND(126.465) FROM DUAL;
SELECT ROUND(126.465,2) FROM DUAL;
SELECT ROUND(126.456,-2) FROM DUAL;
SELECT ROUND(126.456,-1) FROM DUAL;

-- 3. 날짜처리함수
--  1) SYSDATE : 시스템에 저장된 현재 날짜를 반환
SELECT SYSDATE FROM DUAL;
SELECT SYSDATE, CURRENT_DATE,LOCALTIMESTAMP, CURRENT_TIMESTAMP FROM DUAL;

--  2) MONTHS_BETWEEN : 날짜 두 개를 전달받아, 개월 수 차이를 숫자형으로 리턴
SELECT EMP_NAME,HIRE_DATE, MONTHS_BETWEEN(SYSDATE,HIRE_DATE) FROM EMPLOYEE;
--  3) ADD_MONTHS : 인자로 전달받은 날짜에 인자로 전달받은 숫자만큼 개월 수를 더해서 날짜 를 리턴
SELECT SYSDATE FROM DUAL;
SELECT ADD_MONTHS(SYSDATE,4) FROM DUAL;
SELECT ADD_MONTHS(SYSDATE+10,1) FROM DUAL;
--  4) NEXT_DAY : 인자로 전달받은 날짜에 인자로 전달받은 요일 중 가장 가까운 다음 요일날짜
-- 1=일요일, ... 7= 토요일
SELECT SYSDATE+1 FROM DUAL;

SELECT NEXT_DAY(SYSDATE,3) FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'월요일') FROM DUAL;
SELECT NEXT_DAY(SYSDATE,'월') FROM DUAL;
--  5)LAST_DAY : 인자로 전달받은 날짜가 속한 달의 마지막날짜를 구하여 리턴
SELECT LAST_DAY(SYSDATE+30) FROM DUAL;

--  6)EXTRACT : 날짜 데이터에서 년도,월,일 정보를 추출
SELECT SYSDATE FROM DUAL;
SELECT EXTRACT(YEAR FROM SYSDATE)FROM DUAL;
SELECT EXTRACT(MONTH FROM SYSDATE)FROM DUAL;
SELECT EXTRACT(DAY FROM SYSDATE)FROM DUAL;


--  EMPLOYEE 테이블에서 사원의 이름, 입사일, 년차를 출력
-- 단, 입사일은 YYYY년M월D일로 출력
-- 년차 출력 시 소수점이면 올림으로 출력()29.124 -> 30)
-- 출력 시 정렬은 입사일 기준 오름차순
SELECT * FROM EMPLOYEE;
SELECT EMP_NAME, EXTRACT(YEAR FROM HIRE_DATE)||'년'||EXTRACT(MONTH FROM HIRE_DATE)||'월'||EXTRACT(DAY FROM HIRE_DATE)||'일' 입사일, CEIL((SYSDATE-HIRE_DATE)/365) 년차 FROM EMPLOYEE ORDER BY 2;

--  4.형변환 함수
--  1) TO_CHAR : 날짜형데이터, 숫자데이터를 문자형 데이터로 변환하여 리턴
--  TO_CHAR([숫자/날짜데이터],형식)
SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MM/DD/DAY')FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MONTH/DD/DY')FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MONTH/DD/PMHH12"시"MI"분"SS"초"')FROM DUAL;
SELECT TO_CHAR(SYSDATE,'YYYY/MONTH/DD/HH24"시"MI"분"SS"초"')FROM DUAL;
SELECT TO_CHAR(SYSDATE,'FMYYYY/MONTH/DD/HH24"시"MI"분"SS"초"')FROM DUAL;

SELECT TO_CHAR(1000000,'999,999,999')FROM DUAL;
SELECT TO_CHAR(1000000,'999,999')FROM DUAL;
SELECT TO_CHAR(1000000,'$000,000,000')FROM DUAL;

--  2) TO_DATE : 숫자 혹은 문자형 데이터를 날짜형 데이터로 변환하여 리턴
--  TO_DATE(문자|숫자, 포맷)
SELECT TO_DATE(20210201,'YYYYMMDD') FROM DUAL;
SELECT TO_DATE('20210709','YYYYMMDD')FROM DUAL;
SELECT TO_CHAR(TO_DATE(20210201,'YYYYMMDD'), 'YYYY/MM/DD/HH24"시"MI"분"SS"초"')FROM DUAL;

--  3) TO_NUMBER : 문자 데이터를 숫자타입으로 변환하여 리턴
SELECT TO_NUMBER('1,000,000','9,999,999') FROM DUAL;
SELECT TO_NUMBER('100')FROM DUAL;
SELECT TO_NUMBER('1000'+'100') FROM DUAL; --산술연산 숫자로 형변환해서 +연산


-- 5.기타함수
--  1) NVL : NULL로 되어있는 컬럼의 값을 지정한 숫자 혹은 문자로 변경하여 리턴

SELECT SALARY,BONUS FROM EMPLOYEE;
SELECT SALARY,NVL(BONUS,0) FROM EMPLOYEE;
SELECT SALARY,BONUS, ((SALARY+SALARY*NVL(BONUS,0))*12)FROM EMPLOYEE;
SELECT EMP_NAME, NVL(DEPT_CODE,'부서없음') FROM EMPLOYEE;

--  2) DECODE : 여러가지 경우에 선택을 할 수 있는 기능을 제공
-- DECODE(표현식, 조건1,결과1,조건2,결과2,조건3,결과3.....)
/*
    switch(표현식){
    case 조건1 : 결과1;break;
    case 조건2 : 결과2;break;
    case 조건3 : 결과3;break;
    default : 위에 만족하는 조건이 없으면 실행하는 구문
    }
*/
SELECT EMP_NAME, EMP_NO,
DECODE(SUBSTR(EMP_NO,8,1),'1','남자','2','여자','성별없음') 성별
FROM EMPLOYEE;

--  3) CASE : 여러가지 경우에 선택을 할 수 있는 기능을 제공(범위값도 가능)
SELECT EMP_NAME,EMP_NO,
CASE 
WHEN SUBSTR(EMP_NO,8,1)=1 THEN '남자'
--WHEN SUBSTR(EMP_NO,8,1) IN(1,3) THEN '남자'
--WHEN SUBSTR(EMP_NO,8,1) IN(2,4) THEN '여자'
WHEN SUBSTR(EMP_NO,8,1)=2 THEN '여자'
WHEN SUBSTR(EMP_NO,8,1)=3 THEN '남자'
WHEN SUBSTR(EMP_NO,8,1)=4 THEN '여자'
ELSE '성별없음'
END
AS 성별
FROM EMPLOYEE;

--EMPLOYEE 테이블에서 60년대 생 중 65년 미만은 "60년대생 초반", 65년생 이상은 "60년대생 후반"
--단, 이름도 같이 출력할 것
SELECT EMP_NAME,EMP_NO,
CASE
WHEN SUBSTR(EMP_NO,1,2) >=65 THEN '60대년생 후반'
WHEN SUBSTR(EMP_NO,1,2) < 65 THEN '60년대생 초반'
END
AS 나이
FROM EMPLOYEE WHERE SUBSTR(EMP_NO,1,2) BETWEEN 60 AND 69;